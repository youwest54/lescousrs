<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DXF Viewer – ShareCAD‑style</title>
  <style>
    :root {
      --bg:#1e1f25; --panel:#2a2c36; --panel-2:#343746; --text:#e9e9ea; --muted:#a5adba; --accent:#6aa6ff; --danger:#ff6a6a;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: var(--bg); color: var(--text); }
    .app { display: grid; grid-template-rows: auto 1fr auto; height: 100%; }
    .toolbar { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: center; padding: 10px 12px; background: var(--panel); border-bottom: 1px solid #00000044; }
    .left, .right { display:flex; align-items:center; gap:8px; flex-wrap: wrap; }
    .btn { padding: 8px 10px; background: var(--panel-2); border: 1px solid #00000055; color: var(--text); border-radius: 10px; cursor: pointer; transition: 120ms ease; font-size: 14px; }
    .btn:hover { filter: brightness(1.08); }
    .btn:active { transform: translateY(1px); }
    .btn.danger { background:#3b2626; border-color:#00000066; color:#ffdada; }
    .btn.primary { background: #2c3b55; border-color:#00000066; color:#d9e7ff; }
    .btn.small { padding: 6px 8px; font-size: 12px; }
    .input, input[type="text"], input[type="number"], select { padding: 7px 9px; background: #13151b; color: var(--text); border: 1px solid #00000066; border-radius: 10px; }
    .file { display:inline-block; }
    #viewer { position: relative; height: calc(100vh - 200px); min-height: 400px; background:#111317; }
    #canvasWrap { position: absolute; inset:0; }
    .sidebar { position: absolute; top: 12px; left: 12px; width: 280px; max-height: calc(100% - 24px); overflow: auto; background: var(--panel); border: 1px solid #00000055; border-radius: 14px; box-shadow: 0 10px 30px #00000066; }
    .side-head { display:flex; align-items:center; justify-content:space-between; padding: 10px 12px; border-bottom: 1px solid #00000055; background: var(--panel-2); border-top-left-radius: 14px; border-top-right-radius: 14px; }
    .side-body { padding: 10px; display: grid; gap: 8px; }
    .search { width: 100%; }
    .layers { display: grid; gap: 6px; }
    .layer { display:flex; align-items:center; justify-content:space-between; padding: 6px 8px; background:#1a1c24; border-radius: 10px; border:1px solid #00000044; }
    .layer .name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .color-dot { width: 12px; height: 12px; border-radius: 50%; display:inline-block; border:1px solid #00000066; margin-right: 6px; }
    .status { padding: 8px 12px; background: var(--panel); border-top: 1px solid #00000044; font-size: 12px; color: var(--muted); display:flex; gap:16px; flex-wrap:wrap; align-items:center; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; padding:2px 6px; border-radius:6px; background:#0c0d11; border:1px solid #00000088; color:#cbd5e1; }
    .pill { padding: 2px 8px; border-radius: 999px; border:1px solid #00000066; background:#0c0d11; color:#cbd5e1; }
    .row { display:flex; align-items:center; gap:8px; flex-wrap: wrap; }
    .spacer { flex:1; }
    .hidden { display:none; }
    .hr { height:1px; background:#00000055; margin: 6px 0; }
  </style>
</head>
<body>
  <div class="app">
    <div class="toolbar">
      <div class="left">
        <label class="btn file">
          <input id="fileInput" type="file" accept=".dxf" class="hidden" />
          Open DXF…
        </label>
        <input id="urlInput" class="input" type="text" placeholder="Paste DXF URL and hit Load" style="min-width:340px" />
        <button id="loadUrlBtn" class="btn">Load</button>
        <div class="row">
          <label>BG</label>
          <input id="bgPicker" type="color" value="#111317" />
        </div>
        <button id="fitBtn" class="btn">Fit <span class="kbd">F</span></button>
        <button id="resetViewBtn" class="btn">Reset View</button>
        <button id="toggleGridBtn" class="btn">Grid <span class="kbd">G</span></button>
      </div>
      <div class="right">
        <button id="measureBtn" class="btn">Measure</button>
        <button id="exportPNGBtn" class="btn primary">Export PNG</button>
        <button id="clearBtn" class="btn danger">Clear</button>
      </div>
    </div>

    <div id="viewer">
      <div id="canvasWrap"></div>
      <!-- Sidebar: Layers / Options -->
      <div class="sidebar" id="sidebar">
        <div class="side-head">
          <strong>Layers</strong>
          <div class="row">
            <button id="layersAllOn" class="btn small">All On</button>
            <button id="layersAllOff" class="btn small">All Off</button>
          </div>
        </div>
        <div class="side-body">
          <input id="layerSearch" class="input search" placeholder="Search layers…" />
          <div class="layers" id="layers"></div>
          <div class="hr"></div>
          <div class="row">
            <label>Lineweight ×</label>
            <input id="lwScale" type="number" class="input" value="1" step="0.25" min="0.25" style="width:90px" />
            <button id="applyLW" class="btn small">Apply</button>
          </div>
          <div class="row">
            <label><input type="checkbox" id="colorByLayer" checked /> Color by layer</label>
          </div>
        </div>
      </div>
    </div>

    <div class="status" id="status">
      <span id="statusFile" class="pill">No file</span>
      <span id="statusExtents" class="pill">Extents: –</span>
      <span id="statusUnits" class="pill">Units: (DXF)</span>
      <span class="spacer"></span>
      <span>Mouse: <span id="cursor">x: –, y: –</span></span>
      <span>Shortcuts: <span class="kbd">F</span> Fit <span class="kbd">G</span> Grid <span class="kbd">B</span> BG</span>
    </div>
  </div>

  <!-- JS libs -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three-dxf@1.0.4/dist/three-dxf.min.js"></script>

  <script>
    // Globals
    let scene, camera, renderer, controls, grid, raycaster, mouseNDC;
    let dxfGroup = null;                 // THREE.Group produced by three-dxf
    let layerMap = new Map();            // name -> [Object3D]
    let originalMaterials = new Map();   // object.uuid -> material clone
    let isMeasuring = false, firstPoint = null, measureLine = null, measureLabel = null;

    const wrap = document.getElementById('canvasWrap');
    const viewer = document.getElementById('viewer');
    const layersEl = document.getElementById('layers');
    const statusFile = document.getElementById('statusFile');
    const statusExtents = document.getElementById('statusExtents');
    const cursorEl = document.getElementById('cursor');

    function init() {
      const w = viewer.clientWidth, h = viewer.clientHeight;
      // Orthographic camera works best for CAD 2D
      const aspect = w / h;
      const frustum = 500; // initial size; will be fit later
      camera = new THREE.OrthographicCamera(
        -frustum*aspect, frustum*aspect, frustum, -frustum, -100000, 100000
      );
      camera.position.set(0, 0, 1000); // look down +Z onto XY plane
      camera.up.set(0, 1, 0);

      scene = new THREE.Scene();
      scene.background = new THREE.Color('#111317');

      renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(w, h);
      wrap.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableRotate = false; // 2D pan/zoom
      controls.mouseButtons = { LEFT: THREE.MOUSE.PAN, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };

      // Grid (10 units spacing)
      grid = new THREE.GridHelper(1000, 100, 0x444444, 0x222222);
      grid.rotation.x = Math.PI/2; // lie on XY (since GridHelper is on XZ by default)
      scene.add(grid);

      raycaster = new THREE.Raycaster();
      mouseNDC = new THREE.Vector2();

      // Events
      window.addEventListener('resize', onResize);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('click', onClickMeasure);
      // Drag and drop
      ;['dragenter','dragover','dragleave','drop'].forEach(ev => {
        renderer.domElement.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); });
      });
      renderer.domElement.addEventListener('drop', async (e) => {
        const f = e.dataTransfer.files?.[0];
        if (f && f.name.toLowerCase().endsWith('.dxf')) {
          const text = await f.text();
          loadDXFString(text, f.name);
        }
      });

      animate();
    }

    function onResize(){
      const w = viewer.clientWidth, h = viewer.clientHeight;
      renderer.setSize(w, h);
      const aspect = w / h;
      const height = camera.top - camera.bottom;
      const width = height * aspect;
      const centerX = (camera.left + camera.right)/2;
      camera.left = centerX - width/2;
      camera.right = centerX + width/2;
      camera.updateProjectionMatrix();
    }

    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // ===== DXF Loading =====
    async function loadDXFString(text, filename='(string)'){
      try {
        const parser = new window.THREE_DXF.DxfParser();
        const parsed = parser.parseSync(text);
        // Build viewer group
        const opts = { layerColors: document.getElementById('colorByLayer').checked };
        const threeDXF = new window.THREE_DXF.ThreeDxf(parsed, opts);
        const group = threeDXF; // already a THREE.Group
        setDXFGroup(group, parsed, filename);
      } catch(err){
        alert('Failed to parse DXF: ' + err.message);
        console.error(err);
      }
    }

    function clearDXF(){
      if (dxfGroup) scene.remove(dxfGroup);
      dxfGroup = null;
      layerMap.clear();
      layersEl.innerHTML='';
      statusFile.textContent = 'No file';
      statusExtents.textContent = 'Extents: –';
      cancelMeasure();
    }

    function setDXFGroup(group, parsed, filename){
      clearDXF();
      dxfGroup = group;
      scene.add(dxfGroup);

      // Build layers map
      layerMap = new Map();
      dxfGroup.traverse(obj => {
        if (obj.visible === undefined) obj.visible = true;
        if (obj.material){
          // clone material for later changes
          if (!originalMaterials.has(obj.uuid)) originalMaterials.set(obj.uuid, obj.material.clone());
        }
        const lname = (obj.userData && obj.userData.layer) || obj.layer || (obj.material && obj.material.layer) || '0';
        if (!layerMap.has(lname)) layerMap.set(lname, []);
        layerMap.get(lname).push(obj);
      });
      renderLayerList(parsed);
      fitToObject(dxfGroup);

      statusFile.textContent = filename;
      const box = new THREE.Box3().setFromObject(dxfGroup);
      const size = box.getSize(new THREE.Vector3());
      statusExtents.textContent = `Extents: ${fmt(size.x)} × ${fmt(size.y)}`;
    }

    function renderLayerList(parsed){
      layersEl.innerHTML='';
      const entries = [...layerMap.entries()].sort((a,b)=> a[0].localeCompare(b[0]));
      const q = document.getElementById('layerSearch').value?.toLowerCase() || '';
      for (const [name, objects] of entries){
        if (q && !name.toLowerCase().includes(q)) continue;
        // infer color from first object material if available
        let color = '#9aa0a6';
        for (const o of objects){
          const m = o.material;
          if (m && m.color){ color = '#' + m.color.getHexString(); break; }
        }
        const row = document.createElement('div');
        row.className = 'layer';
        row.innerHTML = `
          <span class="name"><span class="color-dot" style="background:${color}"></span>${name}</span>
          <span>
            <input type="checkbox" data-layer="${name}" class="layerCheck" checked />
          </span>`;
        layersEl.appendChild(row);
      }
      // bind
      layersEl.querySelectorAll('.layerCheck').forEach(cb => {
        cb.addEventListener('change', () => setLayerVisible(cb.dataset.layer, cb.checked));
      });
    }

    function setLayerVisible(name, visible){
      const arr = layerMap.get(name) || [];
      for (const o of arr){ o.visible = visible; }
    }

    // ===== Fit to view =====
    function fitToObject(object){
      const box = new THREE.Box3().setFromObject(object);
      if (!isFinite(box.min.x) || !isFinite(box.max.x)) return;
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const margin = 1.1; // 10% padding
      const w = viewer.clientWidth, h = viewer.clientHeight;
      const aspect = w / h;
      let width = size.x * margin;
      let height = size.y * margin;
      // control aspect
      if (width/height < aspect){ width = height * aspect; } else { height = width / aspect; }
      camera.left = center.x - width/2;
      camera.right = center.x + width/2;
      camera.top = center.y + height/2;
      camera.bottom = center.y - height/2;
      camera.position.set(center.x, center.y, 1000);
      camera.updateProjectionMatrix();
      controls.target.set(center.x, center.y, 0);
      controls.update();
    }

    // ===== Measuring =====
    function onMouseMove(e){
      const p = getWorldXY(e);
      cursorEl.textContent = `x: ${fmt(p.x)}, y: ${fmt(p.y)}`;
      if (isMeasuring && firstPoint){
        drawMeasure(firstPoint, p);
      }
    }

    function onClickMeasure(e){
      if (!isMeasuring) return;
      const p = getWorldXY(e);
      if (!firstPoint){
        firstPoint = p.clone();
      } else {
        drawMeasure(firstPoint, p);
        firstPoint = null; // finish segment
      }
    }

    function getWorldXY(e){
      const rect = renderer.domElement.getBoundingClientRect();
      mouseNDC.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouseNDC.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      // intersect with Z=0 plane
      const plane = new THREE.Plane(new THREE.Vector3(0,0,1), 0);
      const ray = new THREE.Ray();
      const origin = new THREE.Vector3();
      const direction = new THREE.Vector3();
      raycaster.setFromCamera(mouseNDC, camera);
      ray.copy(raycaster.ray);
      const p = new THREE.Vector3();
      ray.intersectPlane(plane, p);
      return p;
    }

    function drawMeasure(a, b){
      const dist = a.distanceTo(b);
      // line
      if (!measureLine){
        const geo = new THREE.BufferGeometry().setFromPoints([a, b]);
        const mat = new THREE.LineBasicMaterial({ color: 0xffff00 });
        measureLine = new THREE.Line(geo, mat);
        scene.add(measureLine);
      } else {
        measureLine.geometry.setFromPoints([a, b]);
        measureLine.geometry.attributes.position.needsUpdate = true;
      }
      // label (HTML)
      if (!measureLabel){
        measureLabel = document.createElement('div');
        measureLabel.style.position = 'absolute';
        measureLabel.style.pointerEvents = 'none';
        measureLabel.style.padding = '4px 6px';
        measureLabel.style.background = '#000c';
        measureLabel.style.border = '1px solid #0006';
        measureLabel.style.borderRadius = '6px';
        measureLabel.style.fontSize = '12px';
        measureLabel.style.color = '#fff';
        viewer.appendChild(measureLabel);
      }
      measureLabel.textContent = `Distance: ${fmt(dist)}`;
      // place label midpoint in screen coords
      const mid = a.clone().add(b).multiplyScalar(0.5);
      const screen = worldToScreen(mid);
      measureLabel.style.left = `${screen.x}px`;
      measureLabel.style.top = `${screen.y}px`;
    }

    function worldToScreen(v){
      const proj = v.clone().project(camera);
      const w = viewer.clientWidth, h = viewer.clientHeight;
      return { x: (proj.x + 1)/2 * w, y: (-proj.y + 1)/2 * h };
    }

    function toggleMeasure(){
      isMeasuring = !isMeasuring;
      document.getElementById('measureBtn').classList.toggle('primary', isMeasuring);
      if (!isMeasuring) cancelMeasure();
    }

    function cancelMeasure(){
      firstPoint = null;
      if (measureLine){ scene.remove(measureLine); measureLine.geometry.dispose(); measureLine.material.dispose(); measureLine = null; }
      if (measureLabel){ measureLabel.remove(); measureLabel = null; }
    }

    // ===== UI bindings =====
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      const text = await f.text();
      loadDXFString(text, f.name);
    });

    document.getElementById('loadUrlBtn').addEventListener('click', async () => {
      const url = document.getElementById('urlInput').value.trim();
      if (!url) return;
      try{
        const res = await fetch(url);
        const text = await res.text();
        loadDXFString(text, url.split('/').pop() || url);
      } catch(err){
        alert('Failed to load URL: ' + err.message);
      }
    });

    document.getElementById('fitBtn').addEventListener('click', () => { if (dxfGroup) fitToObject(dxfGroup); });
    document.getElementById('resetViewBtn').addEventListener('click', () => { camera.position.set(0,0,1000); controls.target.set(0,0,0); controls.update(); });
    document.getElementById('toggleGridBtn').addEventListener('click', () => { grid.visible = !grid.visible; });
    document.getElementById('measureBtn').addEventListener('click', toggleMeasure);

    document.getElementById('exportPNGBtn').addEventListener('click', () => {
      const bg = renderer.getClearColor(new THREE.Color());
      const link = document.createElement('a');
      link.download = (statusFile.textContent || 'dxf') + '.png';
      link.href = renderer.domElement.toDataURL('image/png');
      link.click();
    });

    document.getElementById('clearBtn').addEventListener('click', clearDXF);

    document.getElementById('bgPicker').addEventListener('input', (e)=>{
      const c = new THREE.Color(e.target.value);
      scene.background = c;
    });

    document.getElementById('layersAllOn').addEventListener('click', ()=>{
      layersEl.querySelectorAll('.layerCheck').forEach(cb => { cb.checked = true; cb.dispatchEvent(new Event('change')); });
    });
    document.getElementById('layersAllOff').addEventListener('click', ()=>{
      layersEl.querySelectorAll('.layerCheck').forEach(cb => { cb.checked = false; cb.dispatchEvent(new Event('change')); });
    });

    document.getElementById('layerSearch').addEventListener('input', ()=> renderLayerList());

    document.getElementById('applyLW').addEventListener('click', ()=>{
      const scale = parseFloat(document.getElementById('lwScale').value || '1');
      if (!isFinite(scale) || !dxfGroup) return;
      dxfGroup.traverse(o => {
        if (o.material && o.material.linewidth !== undefined){
          o.material.linewidth = (originalMaterials.get(o.uuid)?.linewidth || 1) * scale;
        }
      });
    });

    document.getElementById('colorByLayer').addEventListener('change', (e)=>{
      if (!dxfGroup) return;
      const byLayer = e.target.checked;
      // Reapply materials via originalMaterials or set by-layer colors already baked
      dxfGroup.traverse(o => {
        if (!o.material) return;
        const orig = originalMaterials.get(o.uuid);
        if (orig){
          o.material.color.copy(orig.color);
        }
      });
      // With three-dxf layerColors true/false handled at creation time; for simplicity
      // we rebuild the group to reflect change accurately
      try {
        const parser = new window.THREE_DXF.DxfParser();
        // We cannot reconstruct here without the parsed model; in a full app keep `parsed` around.
        // So we simply update UI note. (Toggle affects new loads.)
      } catch{}
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if (e.code === 'KeyF'){ if (dxfGroup) fitToObject(dxfGroup); }
      if (e.code === 'KeyG'){ grid.visible = !grid.visible; }
      if (e.code === 'KeyB'){
        const col = scene.background.getHexString();
        const next = (col === '111317') ? '#ffffff' : '#111317';
        scene.background = new THREE.Color(next);
        document.getElementById('bgPicker').value = '#' + scene.background.getHexString();
      }
    });

    // Helpers
    function fmt(n){
      if (!isFinite(n)) return '–';
      const abs = Math.abs(n);
      const places = abs >= 1000 ? 0 : abs >= 100 ? 1 : 2;
      return Number(n).toFixed(places);
    }

    // Boot
    init();
  </script>
</body>
</html>
